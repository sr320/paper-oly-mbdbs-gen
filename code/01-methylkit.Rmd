---
title: "01-methylkit"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

### Load libraries 

```{r setup, message=FALSE, warning=FALSE, results=FALSE}
list.of.packages <- c("tidyverse", "reshape2", "here", "methylKit", "ggforce", "matrixStats") #add new libraries here 
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)

# Load all libraries 
lapply(list.of.packages, FUN = function(X) {
  do.call("require", list(X)) 
})
```

## Obtain session information

```{r}
sessionInfo()
```


## Check current directory 

```{r}
getwd()
```

## Download files from `gannet` 

## Create list of all bismark data files, which hav reads that are already trimmed and aligned. These BAM files are also sorted and indexed. 

### IMPORTANT NOTE: The location of these files depends on where the user saved them. I (Laura) used an external hard drive. 

Files were downloaded from gannet on March 9th, 2020 from [https://gannet.fish.washington.edu/seashell/bu-mox/scrubbed/020320-oly/](https://gannet.fish.washington.edu/seashell/bu-mox/scrubbed/020320-oly/) using `curl -O [URL]`:  

https://gannet.fish.washington.edu/seashell/bu-mox/scrubbed/020320-oly/zr1394_1_s456_trimmed_bismark_bt2.deduplicated.sorted.bam
https://gannet.fish.washington.edu/seashell/bu-mox/scrubbed/020320-oly/zr1394_2_s456_trimmed_bismark_bt2.deduplicated.sorted.bam
https://gannet.fish.washington.edu/seashell/bu-mox/scrubbed/020320-oly/zr1394_3_s456_trimmed_bismark_bt2.deduplicated.sorted.bam
https://gannet.fish.washington.edu/seashell/bu-mox/scrubbed/020320-oly/zr1394_4_s456_trimmed_bismark_bt2.deduplicated.sorted.bam
https://gannet.fish.washington.edu/seashell/bu-mox/scrubbed/020320-oly/zr1394_5_s456_trimmed_bismark_bt2.deduplicated.sorted.bam
https://gannet.fish.washington.edu/seashell/bu-mox/scrubbed/020320-oly/zr1394_6_s456_trimmed_bismark_bt2.deduplicated.sorted.bam
https://gannet.fish.washington.edu/seashell/bu-mox/scrubbed/020320-oly/zr1394_7_s456_trimmed_bismark_bt2.deduplicated.sorted.bam
https://gannet.fish.washington.edu/seashell/bu-mox/scrubbed/020320-oly/zr1394_8_s456_trimmed_bismark_bt2.deduplicated.sorted.bam
https://gannet.fish.washington.edu/seashell/bu-mox/scrubbed/020320-oly/zr1394_9_s456_trimmed_bismark_bt2.deduplicated.sorted.bam
https://gannet.fish.washington.edu/seashell/bu-mox/scrubbed/020320-oly/zr1394_10_s456_trimmed_bismark_bt2.deduplicated.sorted.bam
https://gannet.fish.washington.edu/seashell/bu-mox/scrubbed/020320-oly/zr1394_11_s456_trimmed_bismark_bt2.deduplicated.sorted.bam
https://gannet.fish.washington.edu/seashell/bu-mox/scrubbed/020320-oly/zr1394_12_s456_trimmed_bismark_bt2.deduplicated.sorted.bam
https://gannet.fish.washington.edu/seashell/bu-mox/scrubbed/020320-oly/zr1394_13_s456_trimmed_bismark_bt2.deduplicated.sorted.bam
https://gannet.fish.washington.edu/seashell/bu-mox/scrubbed/020320-oly/zr1394_14_s456_trimmed_bismark_bt2.deduplicated.sorted.bam
https://gannet.fish.washington.edu/seashell/bu-mox/scrubbed/020320-oly/zr1394_15_s456_trimmed_bismark_bt2.deduplicated.sorted.bam
https://gannet.fish.washington.edu/seashell/bu-mox/scrubbed/020320-oly/zr1394_16_s456_trimmed_bismark_bt2.deduplicated.sorted.bam
https://gannet.fish.washington.edu/seashell/bu-mox/scrubbed/020320-oly/zr1394_17_s456_trimmed_bismark_bt2.deduplicated.sorted.bam
https://gannet.fish.washington.edu/seashell/bu-mox/scrubbed/020320-oly/zr1394_18_s456_trimmed_bismark_bt2.deduplicated.sorted.bam


```{r}
file.list_18=list("/Volumes/Peach\ Backup/oly-mbdseq-bismark-files_sorted/zr1394_1_s456_trimmed_bismark_bt2.deduplicated.sorted.bam",
"/Volumes/Peach\ Backup/oly-mbdseq-bismark-files_sorted/zr1394_2_s456_trimmed_bismark_bt2.deduplicated.sorted.bam",
"/Volumes/Peach\ Backup/oly-mbdseq-bismark-files_sorted/zr1394_3_s456_trimmed_bismark_bt2.deduplicated.sorted.bam",
"/Volumes/Peach\ Backup/oly-mbdseq-bismark-files_sorted/zr1394_4_s456_trimmed_bismark_bt2.deduplicated.sorted.bam",
"/Volumes/Peach\ Backup/oly-mbdseq-bismark-files_sorted/zr1394_5_s456_trimmed_bismark_bt2.deduplicated.sorted.bam",
"/Volumes/Peach\ Backup/oly-mbdseq-bismark-files_sorted/zr1394_6_s456_trimmed_bismark_bt2.deduplicated.sorted.bam",
"/Volumes/Peach\ Backup/oly-mbdseq-bismark-files_sorted/zr1394_7_s456_trimmed_bismark_bt2.deduplicated.sorted.bam",
"/Volumes/Peach\ Backup/oly-mbdseq-bismark-files_sorted/zr1394_8_s456_trimmed_bismark_bt2.deduplicated.sorted.bam",
"/Volumes/Peach\ Backup/oly-mbdseq-bismark-files_sorted/zr1394_9_s456_trimmed_bismark_bt2.deduplicated.sorted.bam",
"/Volumes/Peach\ Backup/oly-mbdseq-bismark-files_sorted/zr1394_10_s456_trimmed_bismark_bt2.deduplicated.sorted.bam",
"/Volumes/Peach\ Backup/oly-mbdseq-bismark-files_sorted/zr1394_11_s456_trimmed_bismark_bt2.deduplicated.sorted.bam",
"/Volumes/Peach\ Backup/oly-mbdseq-bismark-files_sorted/zr1394_12_s456_trimmed_bismark_bt2.deduplicated.sorted.bam",
"/Volumes/Peach\ Backup/oly-mbdseq-bismark-files_sorted/zr1394_13_s456_trimmed_bismark_bt2.deduplicated.sorted.bam",
"/Volumes/Peach\ Backup/oly-mbdseq-bismark-files_sorted/zr1394_14_s456_trimmed_bismark_bt2.deduplicated.sorted.bam",
"/Volumes/Peach\ Backup/oly-mbdseq-bismark-files_sorted/zr1394_15_s456_trimmed_bismark_bt2.deduplicated.sorted.bam",
"/Volumes/Peach\ Backup/oly-mbdseq-bismark-files_sorted/zr1394_16_s456_trimmed_bismark_bt2.deduplicated.sorted.bam",
"/Volumes/Peach\ Backup/oly-mbdseq-bismark-files_sorted/zr1394_17_s456_trimmed_bismark_bt2.deduplicated.sorted.bam",
"/Volumes/Peach\ Backup/oly-mbdseq-bismark-files_sorted/zr1394_18_s456_trimmed_bismark_bt2.deduplicated.sorted.bam")
```

## The following command reads sorted BAM files and calls methylation percentage per base, and creates a methylRaw object for CpG methylation.
It also assigns minimum coverage of 2x and the treatments (in this case, the Olympia oyster population)

NOTE: according to the below code, an outdated Oly genome version was used in Bismark (most current version is v081). 

```{r, eval = FALSE}
myobj_18 = processBismarkAln(location = file.list_18, sample.id = list("1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18"), assembly = "v071", read.context="CpG", mincov=2, treatment = c(0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1))
```

## Save the MethylKit object; re-doing the previous step is memory/time intensive, so best to use the saved object moving forward. 

Object prepared by Steven in 2019 is also available at https://d.pr/f/vRtrqZ
Object prepared by Laura in March 2020 

```{r, eval = FALSE}
save(myobj_18, file = "../analyses/myobj_18") 
```


```{bash}
#zip ../analyses/myobj_18.zip ../analyses/myobj_18
```

Load object if needed 

```{r}
load("../analyses/myobj_18")
```

## Check the basic stats about the methylation data - coverage and percent methylation. Index the object to look through each sample

```{r}
getMethylationStats(myobj_18[[2]],plot=F,both.strands=FALSE)
myobj_18[[5]]
```

```{r}
getMethylationStats(myobj_18[[13]],plot=T,both.strands=FALSE)
```

```{r}
getCoverageStats(myobj_18[[5]],plot=TRUE,both.strands=FALSE)
```

```{r}
getCoverageStats(myobj_18[[13]],plot=TRUE,both.strands=FALSE)
```

## Filter out loci where coverage is less than 10x or greater than 100x. Then, column bind all samples, keeping only loci that are present in 7 of the 9 samples. Also, destrand. 

```{r}
filtered.myobj=filterByCoverage(myobj_18,lo.count=10,lo.perc=NULL,
                                      hi.count=100,hi.perc=NULL)

meth_filter=methylKit::unite(filtered.myobj, destrand=TRUE, min.per.group=8L)
save(meth_filter, file = "../analyses/meth_filter") #save object to file 
clusterSamples(meth_filter)
```

Percent methylation matrix (rows=region/base, columns=sample) can be extracted from methylBase object by using percMethylation function. This can be useful for downstream analyses. 

Here I create % methylation matrices from the filtered object, and use it to do another cluster analysis 

```{r}
perc.meth=percMethylation(meth_filter, rowids=T)
hist(perc.meth, col="gray50" )

# What percentage of loci have ZERO methylation? 
100*table(perc.meth==0)[2]/table(perc.meth==0)[1] # Only 0.8% of loci unmethylated, averaged across all samples

# Mean % methylation across all samples 
mean(perc.meth, na.rm=TRUE) # 89.3% <-- Hood Canal 

# Mean % methylation for each populaiton 
mean(perc.meth[,1:9], na.rm=TRUE) # 89.3% <-- Hood Canal 
mean(perc.meth[,10:18], na.rm=TRUE) # 89.3%  <-- South Sound 

perc.meth.summ <- data.frame(sample=1:18, methylated=1:18, coverage=1:18, mean.perc=1:18)
for (i in 1:18) {
  perc.meth.summ[i,"sample"] <- i
  perc.meth.summ[i,"methylated"] <-mean(as.vector(getData(meth_filter)[,grep(c("numCs"), colnames(meth_filter))][i][,1]), na.rm=T)
  perc.meth.summ[i,"coverage"] <- mean(as.vector(getData(meth_filter)[,grep(c("coverage"), colnames(meth_filter))][i][,1]), na.rm=T)
  perc.meth.summ[i,"mean.perc"] <- mean(as.vector(getData(meth_filter)[,grep(c("numCs"), colnames(meth_filter))][i][,1]) / 
                                     as.vector(getData(meth_filter)[,grep(c("coverage"), colnames(meth_filter))][i][,1]), na.rm=T)
}
mean(perc.meth.summ[1:9,"mean.perc"])
mean(perc.meth.summ[10:18,"mean.perc"])

```


```{r}
myDiff=calculateDiffMeth(meth_filter,mc.cores=4)
```

```{r}
# get hyper methylated bases
myDiff25p.hyper=getMethylDiff(myDiff,difference=25,qvalue=0.01,type="hyper")
#
# get hypo methylated bases
myDiff25p.hypo=getMethylDiff(myDiff,difference=25,qvalue=0.01,type="hypo")
#
#
# get all differentially methylated bases
myDiff25p=getMethylDiff(myDiff,difference=25,qvalue=0.01)
```


```{r}
write.table(myDiff25p, file = "../analyses/myDiff25p.tab", sep = "\t")
```


```{r}
#write.table(myDiff50p, file = "../analyses/myDiff50p.tab", sep = "\t")
```

---
# Taking the DMLs to a bed

```{r}
library(readr)
#myDiff25p <- read_csv("../analyses/myDiff25p.csv")

```


```{r}
myDiff25p
```


```{r}
library(tidyverse)
```

Also at http://gannet.fish.washington.edu/seashell/snaps/dml25.bed

```{r}
# Write out bedfile for DMLs 
dml25 <-  mutate(myDiff25p, start = start -1, end = end + 1) %>% dplyr::select(chr, start, end, meth.diff) %>%
  mutate_if(is.numeric, as.integer)
write_delim(dml25, "../analyses/dml25.bed",  delim = '\t', col_names = FALSE)

# Write out bedfile for all loci fed into DML analysis, to use as background for enrichment 
mydiff.all <-  mutate(myDiff, start = start -1, end = end + 1) %>% dplyr::select(chr, start, end, meth.diff) %>%
  mutate_if(is.numeric, as.integer)
write_delim(mydiff.all, "../analyses/mydiff-all.bed",  delim = '\t', col_names = FALSE)
```

##  Subset the filtered methylation count dataframe for only those that are differentially methylated. Save object to file. 

```{r}
dml25_counts <- meth_filter %>%
  methylKit::select(meth_filter$chr %in% myDiff25p$chr & 
           meth_filter$start %in% myDiff25p$start & 
           meth_filter$end %in% myDiff25p$end)

class(dml25_counts) #class should be methylBase
perc.methDMLs= percMethylation(dml25_counts, rowids=T) #create a percent methylated object for DMLs

# save count and percent objects 
save(dml25_counts, file = "../analyses/dml25_counts") #save object to be used in subsequent notebook 
save(perc.methDMLs, file="../analyses/perc.methDMLs")
```


### Extract correlation matrix (pearson) and distance matrix (manhattan) from the % methylated matrix
FYI I checked that the correlation matrix in `getCorrelation` is derived from the percent methylated matrix. It is! 

```{r}
cor.pears <- cor(perc.meth, method="pearson") # create pearson correlation matrix. 
dist.manhat <- dist(t(perc.meth), method = "manhattan", diag = T, upper = F)
dist.manhat.df <- reshape2::melt(as.matrix(dist.manhat), varnames = c("row", "col"))

cor.pears.DMLs <- cor(perc.methDMLs, method="pearson") 
dist.manhat.DMLs <- dist(t(perc.methDMLs), method = "manhattan", diag = T, upper = F) 
dist.manhat.DMLs.df <- reshape2::melt(as.matrix(dist.manhat.DMLs), varnames = c("row", "col"))
```

### Read in sample number key, merge with distance matrix dataframes

```{r}
key <- read.csv(here::here("data", "sample-key.csv"))

dist.manhat.df <- merge(x=merge(x=dist.manhat.df, y=key, by.x="row", by.y="MBD.FILENAME"), y=key, by.x="col", by.y="MBD.FILENAME")
colnames(dist.manhat.df) <- c("SeqNum.row", "SeqNum.col", "dist.manh", "SampNum.row", "SampNum.col")
write.csv(dist.manhat.df, file=here::here("analyses", "dist.manhat.csv"), row.names=FALSE) 

dist.manhat.DMLs.df <- merge(x=merge(x=dist.manhat.DMLs.df, y=key, by.x="row", by.y="MBD.FILENAME"), y=key, by.x="col", by.y="MBD.FILENAME")
colnames(dist.manhat.DMLs.df) <- c("SeqNum.row", "SeqNum.col", "dist.manh", "SampNum.row", "SampNum.col")
write.csv(dist.manhat.DMLs.df, file=here::here("analyses","dist.manhat.DMLs.csv"), row.names=FALSE)
```

## Calculate Pst for all methylated loci (using filtered object)

Pst was defined by [Johnson & Kelly, 2019](https://doi.org/10.1111/eva.12912): 

"[Pst is] ... a measurement of epigenetic divergence (st). We defined PST as the methylation analogue of Wrights FST and calculated it for each locus by subtracting the total variance in methylation in all populations from the variance within a single population and divided by the variance in all populations (PST = (VarianceTotal − VarianceSub)/VarianceTotal; Leinonen, McCairns, O’Hara, & Merilä, 2013)."

I looked through their code, and it's not totally clear how they did this calculation. BUT I believe they worked with % methylation data at each locus, so I will do the same. 

```{r}
head(perc.meth, 3)
```

```{r}
perc.meth.Pst <- as.data.frame(perc.meth) 
perc.meth.Pst$var_all <- rowVars(perc.meth, na.rm = TRUE)
perc.meth.Pst$var_hc <- rowVars(perc.meth[,1:9], na.rm = TRUE)
perc.meth.Pst$var_ss <- rowVars(perc.meth[,10:18], na.rm = TRUE)
perc.meth.Pst$Pst.hc <- (perc.meth.Pst$var_all - perc.meth.Pst$var_hc) / perc.meth.Pst$var_all
perc.meth.Pst$Pst.ss <- (perc.meth.Pst$var_all - perc.meth.Pst$var_ss) / perc.meth.Pst$var_all
plot(perc.meth.Pst$Pst.hc ~ perc.meth.Pst$Pst.ss)
hist(perc.meth.Pst$Pst.hc)
hist(perc.meth.Pst$Pst.ss)
```



## Figures

### Hierarchical Clustering using methylation data

The function clusters samples using hclust function and various distance metrics derived from percent methylation per base or per region for each sample.

```{r}
clusterSamples(meth_filter, dist="correlation", method="ward", plot=TRUE)
```


```{r}
PCASamples(meth_filter, screeplot = F)
```

###### Principal Component Analyses

Customized `methylKit` biplots from Yaamini Venkataraman's code,  [https://github.com/epigeneticstoocean/paper-gonad-meth/blob/master/code/04-methylkit.Rmd#L270](https://github.com/epigeneticstoocean/paper-gonad-meth/blob/master/code/04-methylkit.Rmd#L270)

```{r}
#Create dataframe with sample treatment information, color & symbol scheme 
plotCustomization <- data.frame(sample = 1:18, population=c(
                                rep("HC", times=9), 
                                rep("SS", times=9)),
                                color=c(rep("firebrick3", times=9),
                                rep("dodgerblue3", times=9)),
                                symbol=c(rep(16, times=9),
                                rep(17, times=9))) 
PCA.filtered <- PCASamples(meth_filter, obj.return = TRUE) #Run a PCA analysis on percent methylation for all samples. methylKit uses prcomp to create the PCA matrix
summary(PCA.filtered) #Look at summary statistics. The first PC explains 21.9% of variation, the second PC explains 18.3% of variation

require(vegan)

#pdf("../analyses/2018-10-25-MethylKit/2019-11-19-All-Data-PCA.pdf", width = 11, height = 8.5)
par(mar = c(5, 5, 1, 1)) #Specify inner and outer margins
PCA.figure <- ordiplot(PCA.filtered, choices = c(1, 2), type = "none", display = "sites", cex = 0.5, xlab = "", ylab = "", xaxt = "n", yaxt = "n") #Use ordiplot to create base biplot. Do not add any points
points(PCA.figure, "sites", col = as.character(plotCustomization$color), pch = plotCustomization$symbol, cex = 3) #Add each sample. Darker samples are ambient, lighter samples are elevated pCO2
#Add multiple white boxes on top of the default black box to manually change the color
box(col = "white")
box(col = "white")
box(col = "white")
box(col = "white")
box(col = "white")
box(col = "white")
box(col = "white")
box(col = "white")
box(col = "white")
box(col = "white")
ordiellipse(PCA.filtered, plotCustomization$population, show.groups = "HC", col = "firebrick3") #Add confidence ellipse around the samples in elevated pCO2
ordiellipse(PCA.filtered, plotCustomization$population, show.groups = "SS", col = "dodgerblue3") #Add confidence ellipse around the samples in ambient pCO2
axis(side =  1, labels = TRUE, col = "grey80", cex.axis = 1.7) #Add x-axis
mtext(side = 1, text = "PC 1 (21.9%)", line = 3, cex = 1.5) #Add x-axis label
axis(side =  2, labels = TRUE, col = "grey80", cex.axis = 1.7) #Add y-axis
mtext(side = 2, text = "PC 2 (18.3%)", line = 3, cex = 1.5) #Add y-axis label
legend("topleft", 
       pch = c(16, 17), 
       legend = c("Hood Canal", "South Sound"), 
       col = c(c("firebrick3", "dodgerblue3")), 
       cex = 1.6, bty = "n") #Add a legend with information about ambient and elevated samples
#dev.off()
```



# Another PCA option with % methylation matrices  

```{r}
FactoMineR::PCA(perc.meth)
FactoMineR::PCA(perc.methDMLs)
```

### Reshape filtered data to create a new column with sample info, and calculate %methylation for each locus/sample 

```{r}
meth_filter_reshaped <- melt(data=meth_filter, id=c("chr", "start", "end", "strand"), value.name = "count") %>%
 tidyr::separate(col = "variable" , into = c("variable", "sample"), sep = "(?<=[a-zA-Z])\\s*(?=[0-9])") %>%
  dcast(chr+start+end+strand+sample ~  variable) %>%
  mutate(percMeth = 100*(numCs/coverage)) %>% 
  mutate(population=as.character(sample))
meth_filter_reshaped$population <- car::recode(meth_filter_reshaped$population, "c('1', '2', '3', '4', '5', '6', '7', '8', '9')='HC'") 
meth_filter_reshaped$population <- car::recode(meth_filter_reshaped$population, "c('10','11','12','13','14','15','16','17','18')='SS'")
readr::write_delim(meth_filter_reshaped, here::here("analyses", "meth_filter.tab"),  delim = '\t', col_names = FALSE)
save(meth_filter_reshaped, file = here::here("analyses", "meth_filter_reshaped"))
```

### Barplots showing % methylation of DMLs by population 

```{r}
# Look at coverage for each DML, by population 
# mean % methylation across samples  
dml25_counts_unique <- unique(getData(dml25_counts)[,c("chr", "start")])

for (i in 1:nrow(dml25_counts_unique)) {
  temp <-  meth_filter_reshaped %>% 
  filter(chr == dml25_counts_unique[i,"chr"] & 
           start == dml25_counts_unique[i,"start"]) %>%
  group_by(population, chr, start) %>%
  summarise(mean_percentMeth = mean(percMeth, na.rm=TRUE))
    print((ggplot(temp, aes(x = population, y = mean_percentMeth, fill = population)) + 
    geom_bar(stat="identity") + ylim(0,100) +
    theme_light() + ggtitle(paste("Locus = ", dml25_counts_unique[i, "chr"], "_", dml25_counts_unique[i, "start"], sep="")) +
    scale_fill_manual(values=c("firebrick3","dodgerblue3"))))
}
```

## Find which loci are hypomethylated in each population 

```{r}
#Calculate ratio between mean % methylation in Hood Canal : South Sound 
DML.ratios <- meth_filter_reshaped %>% 
  filter(chr %in% dml25_counts_unique[,"chr"] & 
           start %in% dml25_counts_unique[,"start"]) %>% 
  group_by(population, chr, start) %>%
  summarise(mean_percentMeth = mean(percMeth, na.rm = TRUE)) %>% #could instead use ... allCs_percent = 100*(sum(numCs)/sum(coverage)), 
  dcast(chr + start ~ population) %>% 
  mutate(ratio_HC.SS = HC/SS) #in this ratio column, values <1 = HC hypomethylated, values >1 = SS hypomethylated 

# For all loci, calculate mean and sd percent methylation across samples by population 
DML.calcs <- meth_filter_reshaped %>% 
  group_by(population, chr, start) %>% 
  dplyr::summarise(
    mean_percMeth = mean(percMeth, na.rm=TRUE),
    sd_percMeth=sd(percMeth, na.rm=TRUE),
    n())  %>% 
  filter(chr %in% c(DML.ratios$chr) & 
           start %in% c(DML.ratios$start))

# Barplots of all hypomethylated loci in South Sound population 
DML_plots <- list()
for (i in 1:nrow(DML.ratios)) {
  test <- DML.calcs %>% 
    filter(chr==DML.ratios$chr[i] &
             start==DML.ratios$start[i])
  hypo_SS_plots[[i]] <- ggplot(test, aes(x = population, y = mean_percMeth, fill = population, 
                         label=paste0(round(mean_percMeth, digits = 2), "%"))) + 
      geom_bar(stat="identity", width = 0.5) + ylim(0,110) +
      geom_pointrange(aes(ymin=mean_percMeth, 
                        ymax=mean_percMeth+sd_percMeth, width=0.15)) + 
      geom_text(size=3, vjust=-0.5, hjust=1.25) +
      theme_light() + ggtitle(paste("Contig = ", DML.ratios[i, "chr"], ", Locus = ", 
                                    DML.ratios[i, "start"], sep="")) +
    scale_fill_manual(values=c("firebrick3","dodgerblue3"))
}
do.call("grid.arrange", DML_plots)


# use this to call specific contigs 
DML.calcs %>% 
    filter(chr=="Contig26041") %>%
ggplot(aes(x = population, y = mean_percMeth, fill = population, 
                         label=paste0(round(mean_percMeth, digits = 2), "%"))) + 
      geom_bar(stat="identity", width = 0.5) + ylim(0,110) +
      geom_pointrange(aes(ymin=mean_percMeth, 
                        ymax=mean_percMeth+sd_percMeth, width=0.15)) + 
      geom_text(size=3, vjust=-0.5, hjust=1.25) +
      theme_light() + ggtitle("Tonsoku-like protein, DNA repair") +
    scale_fill_manual(values=c("firebrick3","dodgerblue3"))

library(viridis)
library(plotly)
# Heatmap 

test <- meth_filter_reshaped %>%
  mutate(sample=factor(sample, levels = c(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18)))  %>%
  filter(
           start %in% dml25_counts_unique$start & 
           chr %in% DML.ratios$chr)
ggplotly(
ggplot(test, aes(sample, chr, fill= percMeth)) + xlab("Sample") + geom_tile(na.rm = T) +
  scale_y_discrete(limits=(DML.ratios[order(DML.ratios$ratio_HC.SS),]$chr)) + 
  #scale_fill_viridis(discrete=FALSE) 
  theme(axis.title.y=element_blank(),
        axis.text.y=element_blank(),
        axis.ticks.y=element_blank()) + 
  scale_fill_distiller(palette = "YlGnBu", direction = 1))
  #scale_fill_gradient(low="gray5", high="white")
```


# Tiling window analysis 

Summarize methylation information over tiling windows, to then assess differentially methylated regions (DMRs). The function below tiles the genome with windows 1000bp length and 1000bp step-size and summarizes the methylation information on those tiles. In this case, it returns a methylRawList object which can be fed into unite and calculateDiffMeth functions consecutively to get differentially methylated regions. The tilling function adds up C and T counts from each covered cytosine and returns a total C and T count for each tile.

```{r}
#tiles_1000=tileMethylCounts(filtered.myobj,win.size=1000,step.size=1000, mc.cores=4)
head(tiles_1000[[1]],3)

#tiles_200=tileMethylCounts(filtered.myobj,win.size=200,step.size=200, mc.cores=4)
#head(tiles_200)
```

```{r}
meth_tile_filter=methylKit::unite(tiles_1000, destrand=TRUE)
meth_tile_filter 

clusterSamples(meth_tile_filter, dist="correlation", method="ward", plot=TRUE)
PCASamples(meth_tile_filter)
```

## Test for differentially methylated regions 

```{r}
myDiff_tiled=calculateDiffMeth(meth_tile_filter,mc.cores=4)
```

## Test for differentially methylated regions 

```{r}
# get hyper methylated regions 
myDiff_tiled_25p.hyper=getMethylDiff(myDiff_tiled,difference=25,qvalue=0.01,type="hyper")
#
# get hypo methylated regions
myDiff_tiled_25p.hypo=getMethylDiff(myDiff_tiled,difference=25,qvalue=0.01,type="hypo")
#
# get all differentially methylated regions (25% different)
myDiff_tiled_25p=getMethylDiff(myDiff_tiled,difference=25,qvalue=0.01) #only 2 regions! 
```